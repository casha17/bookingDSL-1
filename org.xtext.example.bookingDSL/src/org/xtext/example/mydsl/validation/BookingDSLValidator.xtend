/*
 * generated by Xtext 2.24.0
 */
package org.xtext.example.mydsl.validation

import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.validation.Check
import org.xtext.example.mydsl.bookingDSL.Attribute
import org.xtext.example.mydsl.bookingDSL.System
import org.xtext.example.mydsl.bookingDSL.Booking
import org.xtext.example.mydsl.bookingDSL.BookingDSLPackage
import org.xtext.example.mydsl.bookingDSL.Declaration
import org.xtext.example.mydsl.bookingDSL.Relation
import org.xtext.example.mydsl.bookingDSL.Member
import org.xtext.example.mydsl.bookingDSL.Customer
import org.xtext.example.mydsl.bookingDSL.Resource
import java.util.HashSet
import org.eclipse.emf.common.util.EList
import org.xtext.example.mydsl.bookingDSL.Schedule
import org.xtext.example.mydsl.bookingDSL.Entity
import org.eclipse.xtext.validation.ValidationMessageAcceptor
import org.eclipse.xtext.validation.IssueCodes
import java.util.List

/** 
 * This class contains custom validation rules. 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class BookingDSLValidator extends AbstractBookingDSLValidator {
	
	
	// Validator ensures that "System" starts with an uppercase letter
	@Check 
	def void SystemMustStartWithUppercase(org.xtext.example.mydsl.bookingDSL.System modelSystem) {
		var  isUpperCase = VerifyForUppercase(modelSystem.getName().charAt(0))
		if (!isUpperCase) {
			error("System has to start with an uppercase", BookingDSLPackage::eINSTANCE.system_Name )
		}
	}
	
	// validator ensures that all declerations starts with an uppercase. 
	@Check 
	def void DeclerationMustStartWithUppercase(Declaration decleration) {
		var isUpperCase = Character::isUpperCase(decleration.getName().charAt(0))
		if (!isUpperCase) {
			error("Declarations has to start with an uppercase", BookingDSLPackage::eINSTANCE.baseDeclaration_Name  )
		}
	}
	
	// validation Booking must not have a relation to booking
	@Check
	def void BookingMustNotHaveRelationToBooking(Booking booking) {
		
		for (Member mem : booking.members) {
			if (mem instanceof Relation) {
				if (mem.relationType instanceof Booking) {
					error("Booking cannot have a relation to another booking" , BookingDSLPackage::eINSTANCE.baseDeclaration_Name)
				}
			}
		}
	}
	
	
	// Validation no cyclic relations
	@Check 
	def void checkNoCyclic(Declaration declaration) {
		val seen = new HashSet<Declaration>
		
		if (declaration.CheckForCyclic(seen)) {
								error("Declaration cannot have cyclic dependencies" , BookingDSLPackage::eINSTANCE.baseDeclaration_Name)
		}
		
	}
		
		def boolean CheckForCyclic(Declaration declaration , HashSet<Declaration> seen)  {
			if (declaration === null) return false
			switch declaration {
			Customer :   {
				if(seen.contains(declaration)) {
					true
				}else {
					seen.add(declaration)
					CheckForCyclic(declaration.superType , seen)
				}
			}
			Resource :   {
				if(seen.contains(declaration)) {
					true
				}else {
					seen.add(declaration)
					CheckForCyclic(declaration.superType , seen)
				}
			}
		}
		}
		
		
	// Check if super type already have attribute	
	// needs recursion
	@Check 
	def void CheckIfSupertypeAlreadyHaveAttribute(Declaration decleration) {
		var seen = new HashSet<Declaration>
		switch decleration{
			Customer : {
				val delcartionNameAttributes = decleration.members.map[e| e.name]
				seen.add(decleration)
				CheckSuperTypeCus(decleration , seen , delcartionNameAttributes);
			}
			Resource : {
				val delcartionNameAttributes = decleration.members.map[e| e.name]
				seen.add(decleration)
				CheckSuperTypeRes(decleration , seen , delcartionNameAttributes);
			}
		}
	}
		
		def CheckSuperTypeCus(Customer customer, HashSet<Declaration> declarations, List<String> strings) {
			if (customer.superType !== null) {
				val supertypeAttributes = customer.superType.members.filter(Attribute);
				for (Attribute att : supertypeAttributes) {
					for(String name : strings ) {
						if(att.name !== null) {
							if(att.name.equals(name)) {
							warning('''The attribute already exists in supertype''' , BookingDSLPackage::eINSTANCE.baseDeclaration_Name)
						}
						}
						
					}
				}
				
			}
			
			if(declarations.contains(customer.superType)) {
				return null
			}else {
				declarations.add(customer.superType)
				CheckSuperTypeCus(customer.superType , declarations , strings)
			}
			return null
		}
		
		def CheckSuperTypeRes(Resource resource, HashSet<Declaration> declarations, List<String> strings) {
			if (resource.superType !== null) {
				val supertypeAttributes = resource.superType.members.filter(Attribute);
				for (Attribute att : supertypeAttributes) {
					for(String name : strings ) {
						if(att.name.equals(name)) {
							warning('''The attribute already exists in supertype''' , BookingDSLPackage::eINSTANCE.baseDeclaration_Name)						}
					}
				}
				
			}
			
			if(declarations.contains(resource.superType)) {
				return null
			}else {
				declarations.add(resource.superType)
				CheckSuperTypeRes(resource.superType , declarations , strings)
			}
			return null
		}
	

	
		
	

	@Check 
	def void OnlyResourceAndSchedulesCanOwnBookings(Declaration decleration) {
		
		
		if (decleration instanceof Entity) {
			if (DeclerationHaveSchedule(decleration)) {
				error("Cannot own Schedule" , null)
			}
		}else if (decleration instanceof Customer) {
			if (DeclerationHaveSchedule(decleration)) {
				error("Cannot own Schedule" , null)
			}
		}
	
	}
	
	def boolean DeclerationHaveSchedule(Declaration decleration) {
		var relations = decleration.members.filter(Relation);
		if (relations.isEmpty) {
			return false
		}
		
		for (Relation rel : relations) {
			if (rel.relationType instanceof Schedule) {
				return true
			}
		}
		
	}
	// customer cannot have a relation to resource
	@Check 
	def void CustomerNoRelationToResource(Customer customer) {
		
		for (Relation mem : customer.members.filter(Relation)) {
				if(mem.relationType instanceof Resource) {
					error("Customer cannot have a relation to a resource" , null)
				}
		}
		
	}
	
	@Check
	def void BookingMustHaveThreeRelations(Booking booking) {
  		var bookingsRelations = booking.members.filter(Relation)
		if (BookingsInsufficentRelations(bookingsRelations)) {
				error("Booking must have a has one relation to a resource, customer and schedule", BookingDSLPackage::eINSTANCE.baseDeclaration_Name  )
		}
	}

	private def BookingsInsufficentRelations(Iterable<Relation> relations) {
		if (relations.size == 0) {
			return true
		}
		
		var count = 0;
		
		for (Relation rel : relations) {
			if((rel.relationType instanceof Resource && rel.plurality == 'one') || (rel.relationType instanceof Schedule && rel.plurality == 'one') || (rel.relationType instanceof Customer && rel.plurality == 'one')) {
				count++;
			}
		}
		
		if (count == 3) {
			return false
		}
		return true
	}
	
	
	//@Check
	//def void ConstaintCanOnlyPoint

	@Check 
	def void warnIfNoDisplayName(Declaration declaration) {
		if (declaration instanceof Booking) {
			return;
		}
		
		val attributes = declaration.members.filter(Attribute);
		for(Attribute att :attributes) {
			if(att.name.equals("name")) {
				
			}else {
				if (checkSuper(declaration)) {
					warning("test" , null)
				}
			}
		}
	}

	def boolean checkSuper(Declaration declaration) {
		if(declaration instanceof Customer) {
			if(declaration.superType !== null) {
				return true
			}else {
				return false
			}
		}
		false
	}
	@Check 
	def void errorIfDisplayNameIsNotString(Attribute attri) {
		var attriName = attri.getName()
		if (attriName.equals(("name"))) {
			var attriType = attri.getType().getLiteral()
			if (!attriType.equals("string")) {
				error("Attribute of type name can only be of type string",
					null)
				return;
			}
		}
	}

	def boolean VerifyForUppercase(char character) {
		return Character::isUpperCase(character)
	}
}
