/*
 * generated by Xtext 2.24.0
 */
package org.xtext.example.mydsl.validation

import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.validation.Check
import org.xtext.example.mydsl.bookingDSL.Attribute
import org.xtext.example.mydsl.bookingDSL.System
import org.xtext.example.mydsl.bookingDSL.Booking
import org.xtext.example.mydsl.bookingDSL.BookingDSLPackage
import org.xtext.example.mydsl.bookingDSL.Declaration
import org.xtext.example.mydsl.bookingDSL.Relation
import org.xtext.example.mydsl.bookingDSL.Member
import org.xtext.example.mydsl.bookingDSL.Customer
import org.xtext.example.mydsl.bookingDSL.Resource
import java.util.HashSet
import org.eclipse.emf.common.util.EList

/** 
 * This class contains custom validation rules. 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class BookingDSLValidator extends AbstractBookingDSLValidator {
	
	
	@Check 
	def void SystemMustStartWithUppercase(org.xtext.example.mydsl.bookingDSL.System modelSystem) {
		var  isUpperCase = VerifyForUppercase(modelSystem.getName().charAt(0))
		if (!isUpperCase) {
			error("System has to start with an uppercase", BookingDSLPackage::eINSTANCE.getSystem().getEIDAttribute())
		}
	}

	@Check 
	def void DeclerationMustStartWithUppercase(Declaration decleration) {
		var isUpperCase = Character::isUpperCase(decleration.getName().charAt(0))
		if (!isUpperCase) {
			error("Declarations has to start with an uppercase", BookingDSLPackage::eINSTANCE.getBaseDeclaration_Name())
		}
	}
	
	
	@Check
	def void BookingMustNotHaveRelationToBooking(Booking booking) {
		
		for (Member mem : booking.members) {
			if (mem instanceof Relation) {
				if (mem.relationType instanceof Booking) {
					error("Booking cannot have a relation to another booking" , null)
				}
			}
		}
	}
	
	
	@Check 
	def void checkNoCyclic(Declaration declaration) {
		val seen = new HashSet<Declaration>
		
		if (declaration.CheckForCyclic(seen)) {
								error("Booking cannot have a relation to another booking" , null)
		}
		
	}
		
		def boolean CheckForCyclic(Declaration declaration , HashSet<Declaration> seen)  {
			if (declaration === null) return false
			switch declaration {
			Customer :   {
				if(seen.contains(declaration)) {
					true
				}else {
					seen.add(declaration)
					CheckForCyclic(declaration.superType , seen)
				}
			}
			Resource :   {
				if(seen.contains(declaration)) {
					true
				}else {
					seen.add(declaration)
					CheckForCyclic(declaration.superType , seen)
				}
			}
		}
		}
		
		
	@Check 
	def void CheckIfSupertypeAlreadyHaveAttribute(Declaration decleration) {
		
		switch decleration{
			Customer : {
				val superAttributes = decleration.superType.members.filter(Attribute)
				val attributes = decleration.members.filter(Attribute)
				for (Attribute s : superAttributes) {
					for (Attribute a : attributes) {
						if (s.name == a.name && s.name != "name") {
							warning("Supertype already contains this attribute" , null)
						}
					}
				}
				
			}
		}
	}
		
		def Check(Declaration decleration) {
			
		}
	
	@Check 
	def void CustomerNoRelationToResource(Customer customer) {
		
		for (Relation mem : customer.members.filter(Relation)) {
				if(mem.relationType instanceof Resource) {
					error("Customer cannot have a relation to a resource" , null)
				}
		}
		
	}


	@Check 
	def void warnIfNoDisplayName(Declaration declaration) {
		if (declaration instanceof Booking) {
			return;
		}
		var hasName = false
		var members = declaration.getMembers()
		for (var int i = 0; i < members.size(); i++) {
			var member = members.get(i)
			if (member instanceof Attribute) {
				var attriName = ((member as Attribute)).getName()
				if (attriName.equals("name")) {
					hasName = true
				}
			}
		}
		if (!hasName) {
			// Return warning that there are no name attribute
			warning("This declaration has no name", BookingDSLPackage::eINSTANCE.getBaseDeclaration_Name())
			return;
		}
	}

	@Check 
	def void errorIfDisplayNameIsNotString(Attribute attri) {
		var attriName = attri.getName()
		if (attriName.equals(("name"))) {
			var attriType = attri.getType().getLiteral()
			if (!attriType.equals("string")) {
				error("Attribute of type name can only be of type string",
					BookingDSLPackage::eINSTANCE.getAttribute_Name())
				return;
			}
		}
	}

	def boolean VerifyForUppercase(char character) {
		return Character::isUpperCase(character)
	}
}
